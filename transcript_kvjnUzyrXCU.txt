Cloud DevOps Project - Build an API complete with IaC and CI/CDhi everyone welcome to a new style of
videos that I'm calling micro Cloud
projects my goal is to give you
something that you can get done and in
production in about two hours time so
maybe you have an afternoon maybe you
have a weekend this would be perfect to
get hands on in that amount of time
today we're going to be looking at how
you can deploy your resume API using
Azure serverless services this solution
will run for pennies every single month
so no worries on going over your
learning budget there but I highly do
recommend you set budgets just in case
and you can use this to build other
projects later on maybe it's a micro
service for an additional project you
want to work on later maybe it's the
back end for your portfolio maybe it's
just I don't know sample day that you
need for something who knows the
possibilities are
infinite here alrighty and again the
goal with this course and this project
is to get you hands on and piecing
together the solution in production and
not getting too stuck into the
nitty-gritty details of any specific or
individual technology with all that
being said hi I'm GPS and welcome to
a micro Cloud project this is what we're
going to end up with we are going to
have an API you can see here this is an
in production hosted using Azure
functions
API for us and it's going to return us
Json with our resume information and API
format which I think is pretty cool we
can actually do something like this curl
command here
curl Dash X get and then we just provide
the URL of our API and you can see that
this returns that Json information for
us besides getting Hands-On with Azure
functions we're also going to be using
some devops practices in this case we
obviously have Version Control with
GitHub and git then we have some
infrastructure as code with bicep those
files are here as well and then we have
some continuous integration and
continuous deployment cicd with this
GitHub workflow so plenty to get hands
on with let's get right into it so
you're gonna need a GitHub account and
an Azure account and depending if you
want to work locally or in the cloud you
can use GitHub code spaces to use the
cloud development environment I can I've
configured a Dev
container.json file for us which will
have all the instructions for code
spaces to go and install
everything we need but you can also
click on code well actually after you
Fork the repository click on code and do
local and then clone it locally I would
recommend sticking to one of those too
if you work locally make sure you have
vs code and Docker and the def container
extension you can also choose to work
locally without Docker BS code or the vs
code extension and then install
everything on your own that's going to
take you a little bit more time and
honestly you don't get a lot of value
from spending that much time setting
things up it's more so you know putting
the pieces together of this project so
I'd recommend sticking to one of the two
but yeah
GitHub for Version Control GitHub
actions for CI CD Azure functions to
deploy our API Azure blob storage to
store our resume that Json file we're
going to be
using.net.net6 and c-sharp as the
language for our Azure function and that
function is going to be using an HTTP
trigger and a blob storage binding
GitHub code spaces if you choose so to
be a development environment and then
bicep for our infrastructure s code and
of course you'll need Azure account a
GitHub account and this file my
resume.json I recommend you go ahead and
edit it
and update all the information that you
like to for example here it says name
label image email all these types of
things I've just left it as the default
so go and update that so it returns your
data but I'll be using this dummy data
that's provided for us okay
so you will have the option to let me
open the private browser here you will
have the option to click uh Fork this
will create a copy of this repository in
your own account once you click fork and
you've got it for yourself you're going
to click on code and then either choose
local and then close the cone locally
or hit code spaces and when you hit code
spaces it's going to say create code
space on Main I've already created one
you go and click that you're going to
get a loading screen after that and then
after that you're going to see a screen
that looks like visual Visual Studio
code
except it is going to have
a a URL up here because this is all in
the cloud I'm just going to use code
spaces but again you have the local
options if you'd like to use it as well
on the left side if you click on these
four cubes it says extensions you'll see
that the code space itself has a few
installed
I know that we can go to explore and
then I expand Dev container and then
devcontainer.json and let me zoom in
here a little bit
and we can see that
these are the extensions that I have
told code spaces to install for this
project specifically
vs code Azure functions c-sharp and vs
code bicep however
since we are using an image a Docker
file that already has a bunch of prereqs
for working with Azure functions C
sharp.net6 isolated there are also other
configurations that come along with that
so these extensions are on top of those
configurations for us
the docker file is also in here and you
can see if you're familiar with Docker
and Docker files this is the file that
gives Docker everything that it needs to
go and build the image for you to be
able to work inside of
and
that image is right here okay so
as a summary this folder here.dev
container tells code spaces everything
it needs to create our Cloud development
environment
this isn't a course on dev containers
and code spaces so we won't dive too
much more into that
all right let's go over the project
structure a little more so we covered
what is inside that of that dot Dev
container directory let's now take a
look at the dot GitHub directory and you
can see inside of here we have a
workflows directory and inside here we
have build.yaml which I have open here
as well I'm going to close this so we
have a little bit more space and zoom in
here a bit more
this build.yaml is what is going to tell
GitHub actions to create RCI CD pipeline
cicd stands for continuous integration
and continuous deployment
and this is what is going to allow us to
when we do a certain action to run the
pipeline for us
so in this case on workflow dispatch so
this means we'll have a manual way to
run this workflow and I'll show you that
in a little bit
and whenever we make pushes to the main
branch this workflow will also kick off
at the moment what this is going to do
is grab our app
or a API that is meant to host our Json
information
and deploy it to our Azure function
that we have in our Azure count
so we can see the jobs is to build and
deploy using Ubuntu Dev environment
steps check out getup actions then it's
going to set up our.net environment
we're using 6.net6
and then we're going to run this bash
command here which is going to create a
release for our Azure function
from our Azure function project and grab
that and deploy that to functions and
then it's going to run Azure functions
action
and it uses this here
and then it knows where to publish it
because we're going to provide it a
published profile
again this isn't a course on GitHub
actions specifically so for the context
of this project just keep in mind that
the build that yaml is the file that is
going to create our GitHub actions CI CD
pipeline okay
then we have a vs code inside of vs code
we have an extensions.json which tells
RBS code environment hey these are some
information
about the extensions and in this case
recommendations and it tells the
recommend recommended extensions that we
should have this is also in our Dev
container so it's a little redundant
here but it's here
then we have launch.json
as you know in programming debugging is
a big part of programming
and on this left side we have this run
and debug
and you can see that if we have this
drop down we have an attached to.net
functions which matches this name right
here
so the launch.json is all about
configuring the different tasks that you
can do with debugging
in this case we have a task called
attach to done functions type core CLR
request
type attach and then it's going to
attach to this process ID
which it gets by running this command
and then it runs it attaches to our
Azure function so we can debug it
so remember launch.json is all about
configuring your debugging behaviors
next we have settings
and these are just overall project
settings for vs code for example
the deploy subpath the project language
project runtime and you can Define more
things in here if needed but we don't
need anything else specific for this
project the tasks.json is where we can
configure different types of tasks that
we need to run with our solution so if I
do control shift p or command shift p if
you're on a Mac and then you select
tasks run task you will see that we have
build clean functions clean release
functions Funko start publish functions
and you can see these are all under
configured now you also see that these
names match the names here clean
functions build functions
uh clean release and this is inside of
that tastics.json so very similar to the
launch.json that configures your
debugging tasks
tasks that Json will configure your
other types of tasks like cleaning
building
and running and releasing publishing
types of tasks depending on the stack
you're working with you'll have
different and there are a bunch of
templates that exist out there that
already defined tasks that are pretty
normal or pretty standard with the stack
that you're working with for example for
functions cleaning building publishing
etc etc are pretty standard to be run
this way
so keep in mind tax that Json will
configure that
those tasks and that functionality
inside of vs code okay let's continue to
the infra folder here we have a main dot
bicep and resources dot bicep and you
can see as soon as I clicked one of
these at the bottom right inside of my
GitHub code space it says launching
bicep language service bicep is a
infrastructure as code language built on
top of arm which stands for Azure
resource manager remember that
everything in the cloud is essentially
interacting with an API whether you are
using the UI so you're in the Azure
portal if you're using the Azure CLI if
you're using one of the SDK software
development kits which are ways of using
programming languages to work with your
Cloud platform it all ends up
interacting with an API so it ends up
interacting with code okay
and Azure resource manager is
essentially that API
bicep is an abstraction on top of arm
which is meant to make working with arm
a lot easier because arm is Json and
Json is not a very human friendly
language but bicep is a lot more
straightforward to use and people who
have worked with arm a lot tend to agree
with this opinion
we have main.bicep which you can think
of main sort of like your main method
when you're programming your main method
becomes the the the pieces of or I guess
the lines of code that call the other
methods and the other functionality but
it itself doesn't really do anything
it just orchestrates right so very
similar to main dot bicep
and in here we have a Target scope which
we are targeting subscription
and then we have
our location we have uh we're creating a
resource Group here everything inside of
azure needs to live inside of a resource
Group
and then finally we're telling bicep we
have a module called resources inside of
a resources.bicep file and we're going
to need you to work with that and then
we're outputting some
information to the console and available
in the deployment logs once it is
deployed and once we run this file
then we have resources.bicep which we
are referencing here remember
resources.bicep is going to describe all
the resources that we need to deploy
so remember in that architecture diagram
that I showed at the beginning we
mentioned that we need a storage account
and we have parameters for the app name
for the storage account type
for the run time of the API for the
function app name hosting plan and a
couple other variables that live here on
the top
the First Resource we're deploying is a
storage account
and we're using variables that we've
defined up here to fill in the details
here
we also need a blob service which is
part of the storage account
and then we are creating a container
inside of that blob storage which is
inside of that storage account
finally we're creating a hosting plan
for our Azure function
then we're creating our function itself
and we are defining a couple of app
settings that are specific to deploying
an Azure function with.net 6 out of
process
we are also configuring application
Insight oh one thing I should mention is
an app setting inside of this function
is azure web drop storage which is
referencing the same storage account
that we are creating up here
right here right
because we are uploading our file here
so we need to make sure that it knows
where to look for that information
finally we like I mentioned we're
creating an application insights
instance so we can do monitoring
and we are outputting or printing uh
some more information here so for
example the search account name the
function app name the function URI
that's our infra folder
and the SRC which stands for Source we
have our actual API
inside here we have the get resume.cs
where is where the actual Azure function
lifts and there's only one function in
here
but function projects or function files
can contain as many functions as you'd
like but we only have one called
get resume now this isn't a Azure
functions developer tutorial or course
so the code is very very simple what it
does is it has an HTTP trigger defined
right here
so that means that this code is going to
execute when we visit the endpoint or
its URL
as soon as it's executed what it's going
to do is get a blob input so it's going
to go to that blob container we created
and then go to the folder resume
and then find the file my resume.json
and grab all of that content and save it
into a string
called my resume
then it's going to print the console
something like this text inside of here
it's going to create a response with an
HTTP status code dot okay and then to
that response it's going to add the
headers
basically is telling it hey I'm going to
give you Json information
and we're going to write the information
that that contains
the Json which is that string right the
body of our file is inside of the string
called my resume so we're going to add
that resume to our response and they're
going to return our response
very straightforward and simple code
here and perhaps in later on courses we
can build on this that's my actual goal
is to build on this project
so you all can get Hands-On on not only
implementing a straightforward and
simple project but also how you can
refactor potentially later on
add more things perhaps this is the
first part of a microservices project
who knows we'll see what happens
but that's our code here
we also have a host.json file
which configures how the host of our
Azure function Works in this case
it tells logging or using application
insights and it's setting the sampling
settings here
and depending on how much logging
information you want sent to your
function you would configure different
settings in here as well
we can also configure how our extensions
extensions are the triggers and bindings
so in ways that we can get information
in and information out of our functions
we can configure them in here
the only configuration I have is for our
HTTP extension our route prefix we want
it to be empty by default it's API and
you don't even have to Define it because
that's just a default but if you want
there to be no API there we're going to
remove that I'll show you what this
means once we deploy it
next we have our local Dot settings.json
local.settings.sample.json
and this file is where we save all of
our configuration settings so any
connection strings any secrets that you
need to work with if you're developing
locally
or not in production you would save them
in here but this file does not get
deployed to production so keep that in
mind
there are other ways and in fact if we
go to the info folder in the resources
remember I showed you that
when we're deploying the function we're
setting one of the app settings to
include the value for Azure web job
storage so you see this
and it's grabbing the the storage
account name which is a search account
in production once it gets deployed
and grabbing that connection string and
it's putting it in this Valley you see
this value Azure web job storage matches
this local dot settings.sample.json in
here Azure webjob storage we just don't
have that
key here quite yet
but we'll put that in later but remember
this local sings that sample.json is for
local
development only okay then we have a
program CS
which is specific to the net Azure
function and this school configure how
our function works if you use dependency
injection you need to set up any
middleware or things of that nature you
would use your program at CS for that
finally we have our DOT CS proj which
defines different settings for the
project
for example the namespace any packages
you'll need to use I already have a
couple in here that we're going to need
to use
and where you can find your local that
says.json and things of that nature
alrighty
and finally in here I have the diagram I
have the my resume Json sample file and
then read me with instructions
and that's about it for the directory
structure okay speaking about the readme
we're going to click on the top here it
says open preview to the side and then
we're going to be able to see the
markdown in a little bit more of a
easier to read fashion I'm also going to
close this here
and we've already covered how to get
started so now we can move into how to
authenticate with your Azure environment
uh since we aren't code spaces we're
going to have to use these First Command
here and we can just copy these things
here so AZ login
I'm going to be using the CLI to
interact with Azure sometimes I might
have to reference something in the
portal but I'll try to use that the
least my goal is to give you all the
most efficient way or a more efficient
way than clicking around the portal and
using clis using sdks using different
devops practices
is always going to be better than
clicking around in a portal okay so
first we're going to copy that I
mentioned you need to have an Azure
account or else you won't have anything
to log into
you're going to click
enter I guess you're going to hit enterand this is going to give you a code and
a URL for you to go and visit
that URL is right here I'm going to
click on that and then provide that code
so I'll be right back
okay I've successfully logged in and it
should give you an output of all your
subscriptions in Json as you can see it
here
now if you do AZ account list dash dash
output
dash dash output and then table it's
going to give you a list of all the
subscriptions that you have available so
now what you have to do is AZ account
set Dash subscription
and this is going to allow us to set
which subscription we want to work with
in my case I want to work with visual
Visual Studio
enter prize
subscriptionfantastic and now if I do AZ account
show
if you do Dash o that stands is the same
as doing dash dash dash output but you
can also just do Dash o safety time
table this is going to show you the
subscription that is set for you to work
with which we just set right and you
just want to make sure that that name is
the account that you want to work with
okay
so now that we've authenticated with our
animation environment we can go ahead
and use the CLI to provision resources
which is the next step
okay so as a heads up and you can see I
have the note written here I've set the
resource Group name to be RG Dash
serverless resume API okay so keep that
in mind so if I don't set that value
anywhere it's because I've configured it
already I've also provided us those
infrastructure as code files which is in
that infra folder those two bicep files
that we went earlier so now we can
create a deployment by copying this
command here
and the only thing we have to change is
the region I'm going to use East U.S
east us2 because that's the region
that's closest to me but you can go
ahead and type in the region that works
best for you we're going to hit enter
and this is going to ask us for our
region once more because our
infrastructure files are asking for that
East us2
and then this is going to go ahead and
create everything that we have defined
in those
infrastructure s code files and this is
why a devops practice like
infrastructure as code is so crucial to
becoming efficient in building efficient
Solutions and infrastructures in Azure
or in cloud in general
if you didn't have something like this
in place you would have to manually go
either use individual commands or some
sort of programming language or click
through the UI which is the worst option
to create everything you need but since
we have files that are already
describing via code what we need we can
just run a command to use those files
and deploy everything for us
so I highly recommend this is something
that you implement even if your projects
are straightforward
also you never have to come up with
these from scratch there are so many
templates that you can use to start off
with for example this one here I found
some are probably on GitHub or maybe
even even in the official Azure
functions documentation
oftentimes services will provide
examples of different infrastructure as
code languages two go ahead and use this
templates to deploy those things all
right so we got some output and we see
provisioning State here at the bottom to
succeed it so what you can do now is do
a z group
uh list and then do output table and
let's take a look at the list of
resource groups that we have available
in our
subscription
and you can see here we have the RG Dash
serverless resume API so it was created
successfully fantastic so we're going to
copy this next command here that's AZ
deployment group show
we're providing the resource Group that
we've created and then we need the
deployment called resources and then
we're going to query for
properties.output because this command
is going to give us the values for our
storage account and function app name
and that's because remember at the
bottom of those files I said there are a
couple of outputs and these will be the
outputs in the deployment logs well
we're going to query for those outputs
now so we have our function app name
and the values here we have our function
URI here and then storage account name
so what I'm going to do
is create function app name variable and
then set it to this value here
so I'm just going to copy this herethen I'm going to type in function URI
and then copy this value here
and then I'm going to create storage
account name so we are sending variables
and this is specific to bash
to The Bash shell and not to the Azure
CLI
great so the reason I did that is
because now I can do Echo and then do
function I think I called it function
app name and then it's going to provide
me that value Echo
storage account name and the values
there as well so I don't have to
remember this memorize this I can just
use these variables here now fantastic
so now we need to upload the sample Json
file that I provided so that my
resume.json
to the newly created blob container so
we're going to copy this value here
or this command here paste it in here
and we're just going to
replace the parameter values so for
example the first thing is account name
and we're going to use that variable
storage account name
the container name is resume the name is
res my resume.json in the file is the
file the path is also my resume.json so
that's all we need to change
so we're going to hit enter
and there we go that has uploaded for us
so here it says it gives you a little
warning about authentication but since
we're using the CLI it's going to work
fine for us
and in our local dot settings.json we
need to add the storage account
connection string remember I mentioned
that when we're working locally even if
it's a cloud development it's not in
production so we're using GitHub code
spaces now but it's still considered not
a production because we're developing
right
so inside of this file we need to give
this Azure web job storage a value
because right now it's blank
also one thing I forgot to mention is we
have to right click and rename this so
we just have to remove the sample from
there so it needs to be
local.settings.json okay because that's
just the format that they use for that
file okay so now back to our readme we
can close we can go back in here
and we're going to copy this command
here as well
and for the storage account name we're
going to use that variable once more
and it would be storage remember to use
the dollar sign there at the beginning
because that tells our
command line that we are using a
variable and the resource Group is
rg.serverless
resume API I need to update that in the
documentation here
where'd it go
RG dot serverless resume API I'll make
sure to push that update there too okay
and then you're given a connection
string value so you're going to copy
what's in the double quotesactually you can copy the whole double
quotes there just copy everything that's
here
go back to your local settings.json
remove the double quotes there and then
paste it in there perfect now your value
is in there
fantastic and now we can run and debug
so remember I mentioned that we have
these debugging tasks
inside of the launch.json and that when
you go to run debug tab here this drop
down what is in here matches what's in
here well now we should be able to hit
run here
and because we have everything
configured correctly this should work
for us locally
so our Command here is going to now
return us a function URI
even though this is working in the cloud
with GitHub code spaces this again still
is considered a development environment
so as soon as you stop debugging this
the URI or the URL will disappear
and it will stop working correct so
you're going to get this your
application running on Port 1771 is
available
see all forwarded ports and you can open
a browser or you can control click herethere you go follow link and you can see
it's
I did some redirecting for us that's
some code Space Magic and you see our
API is here as well so I think if I copy
this and if I do something like let me
open up another terminal here
I do curl curl curl might not be
installed here
oh it was and you can see it is
returning us some information here let
me see what happens if I do curl here in
my terminal
and we also get some information
returned here so we do get our API uh we
do see that our API is in the URL that
the code space is generating for us okay
so now what we can do is we can
configure our CI CD with GitHub actions
so we can actually see this thing in
production I'm going to go ahead and
disconnect the debugger so that'll stop
running it for me
and we're going to close this message
here and then this should also not work
anymore because
the debugger stoppedinteresting well this isn't going to do
up to date
uh keep that in mind okay so now we need
to get the functions published profile
because I mentioned that when we go into
our
GitHub build.eml at the bottom it's
using a published profile to know where
to publish to in Azure functions so
let's close this here and we'll close
this here and we're going to copy this
Command right here actually I'm going to
make this
rg. serverless resume API because I know
that is the value of the
research group name paste this in here
and the only thing here I need to change
is the function name which again we
saved in that shell variable that is
function
uh name and let's go ahead and run that
and we are attaching the dash dash XML
whoops what happened to your function
app name do we not have that
function app name no function app
function what did I call it function
name
oh it looks like the oh hold on I mean
the wrong one I need to be over here my
mistake yeah so it's an environment
variable but that
just to that environment and you could
have a bunch of terminals but each
exists in its own environment so you see
that I had a different shell open here
so
the
environment variables don't save you can
have configure it to save across
environments but that's not the case
here so function app name so this is
just local so here it is okay so now I
have to
copy this
and then again change that to
say the scope of environment variables
will depend on if it's local if it's
Global et cetera et cetera function app
name
and we can run that
and you're going to copy everything that
comes in here fantastic
so now you gotta go to your GitHub
repository and then we're going to
create a secret named Azure underscore
function app underscore publish
underscore profile
and let's go to here go to settings and
then you're going to go to Secrets
sections
and I already have one here so I can
just hit edit and then paste in that
value and hit update secrets and I have
to authenticate so now we can head to
the actions tab
here and we can see we have deploy.net
isolated Azure function
and this actually matches if we go to
our build.yaml this name that's up up
here
deploy.net isolated
Azure function appokay so because we have it to run when
either when it's manually dispatched or
when a push happens to the main branch
it's going to run so let's do that first
one
I'm going to click run workflow on the
branch Main and hit run workflow and
we're going to let it run
now also I'm going to do is go to the
Azure portal go to function apps you
might need to search for it and then go
to the Azure function that's inside of
that Resource Group that we created
click on that there
and on the left side we see functions
nothing is here because nothing has been
deployed yet
let's go back to that build in the
actions let's click on it here and it's
yellow status right now it's saying
deploying to Dev so let's give it a few
momentsit looks like our action has run
correctly
set up job check out looks like we've
got check marks on everything and you
can expand these and take a look at more
of what happened in each one of those
individually
so let's go back to our function up here
and let's hit refresh here
we might actually need to refresh the
whole page Let me refresh this
go back to our function
let's give it one more second hereto play one I mean refresh it once more
and here it is get resume which is the
name of our function remember
and now if I click on here and then I
click on Code test you can get your
URL but also uh we I guess we can just
click on here
code plus test this is going to load
some information on our function then we
can click get function URL copy this
here and then paste in here
paste and gooh actually see this is not gonna work I
think I found a bug that I'll have to
tell the team because my host.json
specifically says that this function
should not use the API prefix so if I go
here
and remove the API we can now see that
our API information is
our resume information is now displayed
to us in API in our function API
so that was interesting this URL does
not work
uh let's go back to the function itself
go to overview and then you have your
url here
and you see here your functions 4.0 app
is up and running so it's a little
confusing with the wording of functions
a function project can contain multiple
individual functions
so for example this is a function app
this is a function project and the URL
to the whole thing is here and then
functions you can have a bunch more in
here and each one itself will have a URL
as well it's usually I mean it's always
going to be
the function app project URL slash the
name of the function you may have
prefixes there as well
okay so now we have our resume API in
production now if you do something like
uh curl now
curl and provide that you can see that
our content is here as well lovely
and this is now an in production
and in your Azure API if you do curl
Dash X and then provide get and then the
URL of your
function
and you will get the Json information
returned to you and I should have shown
that when I was running the curl
commands before but
better late than never now I did mention
that the GitHub action so the cicdi
pipeline will also run when I make
pushes to the main branch
so let's go back here and I'm just going
to run a git status because I'm sure
I've changed some things
so I modified the readme with
instructions and then I deleted this
file here well I ended up renaming so
what I'm going to do is do git add
and then we're going to add my changes
and then hit commit
and the updated readme
now I can do git push
and we see that the push was done to our
main branch because I am on my main
branch and then if I go back here to my
GitHub actions we can see that the
action the deploy.net isolated Azure
function action is running
and it's running because I made that
push with the commit message updated
readme
to that Branch so it's going to run as
well now I actually do have to make one
more change here
and I have to rename this back to
local.settings.sample.json because if
not
the git ignore is going to tell GitHub
and git to ignore the localized things
that Json and then this file won't
appear for you all but I'll make that
change
in the well outside of this video but
yeah everyone that is the end of this
micro Cloud project and I would highly
recommend building this one because I'm
going to be building more micro projects
on top of this oneand that's it uh now you have a cloud
project in your GitHub in production and
I hope you got Hands-On and you learned
something new
alrighty I'll see you in the next one